\documentclass[11pt, a4paper, ngerman, twoside]{article}

%% Die folgende Anleitung gilt für Linux:
%%
%%  Die Übersetzung dieses Dokuments erfolgt mit (ggf. öfter aufrufen):
%%  pdflatex seminar.tex
%%
%%  Falls die Bibliographie geändert wurde, dann zusätzlich:
%%  bibtex seminar
%%
%%  Bitte darauf achten, dass pdflatex und bibtex keine Warnungen und
%%  keine Fehler melden.
%%
%%  Das Ergebnis kann man ansehen:
%%  acroread seminar.pdf
%%
%%  Die Quelldatei einer deutschen Rechtschreibprüfung unterziehen:
%%  ispell -d deutsch -T latin1 seminar.tex

%%  Zur Unterstuetzung von Umlauten:
%\usepackage{ngerman}
%%  Die Kodierung des Dokuments wird angegeben durch:
\usepackage[utf8]{inputenc}

\usepackage{amssymb,amsthm,graphicx}
\usepackage{hyperref} % important: load after float
\hypersetup{
	pdfproducer={pdfeTex 3.14159-1.30.6-2.2},
	colorlinks=false,
	pdfborder=0 0 0	% keine Box um die Links!
}

\oddsidemargin0mm
\evensidemargin0mm
\textwidth159.2mm
\topmargin0mm
\headheight0mm
\textheight43\baselineskip
\usepackage{url}
\urlstyle{rm}

%%  Die Seitennumerierung wird später von uns korrigiert.
\setcounter{page}{1}

%% Die Konfiguration eigener Header und Footer
%% ermöglicht beispielsweise das Paket
\usepackage{fancyhdr}
%% Die folgenden Zeilen konfigurieren das Paket für unsere Zwecke
\fancypagestyle{plain}{\fancyhf{}\fancyfoot[RO,LE]{\thepage}\renewcommand\headrulewidth{0pt}}
\fancyhf{}
\fancyhead[LE]{\myauthor}
\fancyhead[RO]{\mytitle}
\fancyfoot[RO,LE]{\thepage}
%% Hier setzen wir den Stil der Seiten des Dokuments so,
%% dass das von uns konfigurierte Paket fancyhr verwendet wird.
\pagestyle{fancy}

%%  Die Theorem-Umgebungen sind in amsthdoc.pdf beschrieben:
\renewcommand{\proofname}{Beweis}
\theoremstyle{plain}\newtheorem{Lemma}{Lemma}
\theoremstyle{plain}\newtheorem{Satz}[Lemma]{Satz}
\theoremstyle{definition}\newtheorem{Definition}[Lemma]{Definition}
\theoremstyle{definition}\newtheorem*{Beispiel}{Beispiel}
\theoremstyle{remark}\newtheorem*{Bemerkung}{Bemerkung}

%% Das Argument zu Date soll leer bleiben, 
%% damit dem Titel kein Datum hinzugefügt wird.
\date{}

% % % Ab hier sollte das Dokument bearbeitet werden! % % % 
%% Eigene \usepackage und \newcommand Befehle sind hier einzufügen.
%% Vor der Verwendung anderer Pakete muss eine Rücksprache mit dem Betreuer erfolgen.
% % %

\newcommand{\isdef}{=_{\mathrm{def}}}
\newcommand{\N}{\mathbb{N}}

\begin{document}
%%  Die Überschrift der Ausarbeitung ist zwischen {}
%%  in der nächsten Zeile einzutragen.
\title{Cognitive Questions in Software Visualization}
%%  Der Name des Autors oder die Namen der Autoren sind 
%%zwischen {} in der nächsten Zeile einzutragen.
\author{Frank Richter, Tamino Hartmann}

%%  Die nächste fünf Zeilen müssen unverändert bleiben!
\makeatletter
\let\mytitle\@title
\let\myauthor\@author
\makeatother
\maketitle
%% ab hier darf das Dokument wieder verändert werden!
\begin{abstract}



\end{abstract}

%%  Der Text der Ausarbeitung ist hier einzufügen.
%%  Er sollte 8-10 Seiten umfassen.
%%  Die Gliederung erfolgt mit \section und \subsection Befehlen.
%%  Referenzen innerhalb des Texts erfolgen mit \label und \ref Befehlen.
%%  Referenzen auf Literatur erfolgen mit dem \cite Befehl.
\section{Introduction}
The goal of software visualization is to help the reader understand a complex matter. It is trying to make up for inexpertness in readership by expertise in presentation. The major difficulty with software visualization lies in the fact, that it is presenting information artefacts and not physical objects. Another problem poses the question what kind of visualization is actually suitable for which situation.
There are different types of visualizations to represent the code, the data or the algorithm\cite{myers}. Additionally there should be made a distinction between external structure versus representation of cognitive structure and representations of structure versus representations of purpose or expectation\cite{origin}.

Each type of visualization has different aims and uses. A visualization that is presenting large data sets is making the attempt to provide a data picture that makes the data available for interpretation, while a visualization in form of a virtual machine is mostly used to show how a program behaves. Other visualizations try to change the perspective, to attempt to control complexity by visualizing the overall structure. Another type of visualizations are those that attempt a display-based reasoning by shifting the focus of the representation to allow the user different tactics in finding, recalling, examining, or comparing information\cite{davies1993}\cite{davies1996}.

Currently we are lacking software visualisations that are concentrating on a cognitive representation and, aside from the domain of code, don't even really know to represent something in a cognitive way.


\section{Reasons for using Software Visualizations}

One of the questions that need to be answered for this paper is the reasons for using visualizations when developing software. The original paper does this by dividing visualizations into two distinctions: one concerning when software experts use them and one when non-experts use visualizations. It is important to note though that the two are not exclusive, meaning that a visualization can be utilized by both groups too.

Experts use software visualizations for example to externalize images of thought, to set aside information, to create a focus for transferring knowledge transfer, to provide tools for thinking, and to fully utilize the computer as a collaborator when solving problems.

Externalizing images of thought are done by visualizations that are closely modeled after the mental image the expert has. Using visualizations to set aside information is used to keep a problem solvable in manageable chunks by freeing already thought about parts from parts that still need work. When the visualization is focused on knowledge transfer, the intention is often to make a discussion easier by offering a common ground from which to work. Visualizations that are used as an aid to a process of thought are used as tools. These supplementary representations are used to offload information, to provide alternative views of a problem, to provide a visual mapping of the problem, and to provide a possibility for the expert to keep track of the relationships between sub-problems. Visualizations that are created to use the computer as an active collaborator are used to keep track of what the computer does towards solving the larger problem, such as when a solution is not apparent and the path to it must be taken step by step.

Non-experts use visualizations mostly as a tool to get a glimpse of an expert's mental imagery, an expert's reasoning process, to provide tools for them that are consistent with how an expert behaves, to provide a model of execution, and to show additional information or aspects that are hard to envision for novices.

For providing a glimpse of an experts imagery is important for novices to get some expert insight. When faced with an expert's reasoning process, the novice often cannot follow the the reasoning the expert took, so a visualization can be used to make explicit thinking more clear to them – much like a scaffold. Using visualizations as tools, a novice can be taught how an expert behaves on a given problem, thus allowing them to grow into a professional mindset. Novices also use visualizations to show them the model of execution; this can be important because they lack the working knowledge of experts how software is run by the computer. Lastly, novices use representations to show additional information and aspects that are not obvious to them but to experts; this teaches them how to successfully sort out important information.

Comparing the two, the original paper states the assumption that novices have a less developed or inappropriate mental imagery as compared to experts. Generally, one could fathom that visualizations are used as tools by experts for specific problems and as aids by novices to understand how an expert would tackle a task. Worded differently, visualizations for novices often have an instructive role as compared to when they are utilized by experts. It becomes apparent that to understand a visualization, an insight into their use is required.

\section{Graphical Visualizations and their Aspects}

It is difficult to clearly distinguish visualizations from other ways of viewing software. An important point when considering this is that in print media, there is no longer a clear separation between graphics and typography. Therefore the original paper comes to the conclusion that visualizations are in essence an alternative representation or alternative emphasis within a representation. However, it is interesting to note that there is evidence that graphical representations are proving harder to work with when compared to purely textual ones. So when should they still be used? Mainly when a richer representation is required, when accessibility and comprehensibility are important, and when the interaction should be more fun for the people who will utilize it\footnote{This is because creative working is encouraged stronger when a representation is more graphical.}. Especially accessibility can be an important point to consider, as the illusion of accessibility can be more important than general effectiveness to encourage actual use of the representation.\footnote{TODO: I kept it REALLY short here, can be expanded!}

\section{Concepts of Visualizations}

\subsection{Tasks of Visualizations}

The task of a visualization is to support the user towards what he intends to do. However, visualization systems rarely come with a description for which tasks they are intended to support specifically. It has been shown that programmers that cross-reference between the program world and the domain world receive the higher comprehension scores\cite{penn}. The original paper therefore concludes that to be helpful, a visualization not only needs to illustrate the code but also the algorithm in a useful form.

There are two axioms about information representation: finding and using information is easier when the form of the information sought has a cognitive fit; and presentation highlights some kind of information but likely obscures other kinds at the same time. These might explain why some animation systems using code steppers have not proven to be generally successful methods in helping code comprehension, as they force the user to view the code in order of execution compared to goal-oriented, the most sought after information users try to extract.

To utilize the axioms effectively, it is necessary to understand what programmers actually do, how to support them in their tasks, and how visualization systems change these tasks.

\subsection{Information Dimensions in Visualizations}

Different visualizations are using different dimensions for the representation of information. Text is linear and apparently has one dimension, while a picture is two dimensional. An animated visualization is basicly moving pictures what is adding another dimension to the two dimensions pictures initially have. By using a virtual reality system that the human brain interprates as something three dimensional it is possible to add another dimension.

Taking a closer look at text one will notice, that text actually is not one dimensional. Code was not written in a linear way and no one but a compiler reads it in a linear way. Human readers of source code take not of secondary notation \cite{green} like indentation, patterns, text formation and comments with ASCII signs.

In printed graphic image there are eight variables\cite{bertin}. There are the X and Y dimensions and marks with the density of ink, sizie, texture, color, orientation and shape as variables. This is e.g. used in editors with syntax highlighting.

Due to the limited view of a human, using more than two dimensions comes at a cost. One will basicly allways be limited to a two dimensional picture of one specific point of time. This leads to the conclusion, that it might be best if one first tried to represent as much information as possible by using only two dimensions.

\subsection{Influence of Personal Skill and Variation}

The aim all software visualization is to highlight information; most of the time specifically one information out of a multitude. The goal of this is to allow the user to access and work with information more easily. However, accessing and working with information is strongly connected to how we interpret what we perceive based on what we have learned about interpretation. This can be broken down into a set of skills.

First is readership skills. Here, the original paper means how capable the consumer of information is in separating non-relevant information from relevant one. This is closely tied with visibility. It is important to note though that a high visibility does not guarantee effective interpretation. Expert users are capable of correctly sorting out all the relevant information regardless of how visible it is.

Ingrained into all of us is also the influences of our graphical cultures. These are secondary notation elements that have not been explicitly defined anywhere but have been taught to us by simple cultural conventions. To outsiders, the difference in conventions might well be strong enough to make information completely inaccessible.

Also important are representational skills. When creating visualizations, it is often hoped that expertise in representation of information can counter inexperience in readership skills. This can be done by directing the attention of the user to the relevant information by providing cues. However, this requires support by for example explicit conventions and tools to be fully useful.

Lastly is cognitive style. It describes the level of experience in personal expression, perception, and interpretation skills. Basis of these is the acceptance that results will differ among different users as well as individual visualizations\footnote{TODO: Reword, too close to original!}.

Apart from the skills of the user, one can also clearly how the level of expertise plays an influential role in visualizations. One can question whether visualizations intended for experts are suitable for novices or the other way around. To start somewhere, the original paper first considers why experts create visualization tools for themselves and the characteristics of these tools.

Many of the visualizations made by third parties such as debuggers or execution models only visualize a single paradigm. While this might be useful for novices who lack basic understanding in these areas, experts have no need for these. Experts tend to know the boundaries and problems of paradigms and strive to work beyond them. Most problems that experts face are not problems within a given paradigm but abnormal behavior of entities within the paradigm where the error lies outside of it\footnote{TODO: This might need to be reworded... is the core aspect clear?}. This leads experts to creating visualizations for just a single problem. Some of the most difficult problems involve multiple different tools and their interaction; therefore, an expert's visualization is created for coping with unknowns. These visualizations are deemed worthwhile to create when the net gain is considered significant enough to warrant the effort, such as when taking over someone's program, tackling large problems, or when problems cross domains.

So why don't experts use other people's visualizations more often? The answer lies in the fact that many expert visualizations were created only for a specific problem in a specific program, and is thus too specialized to be used elsewhere. Another problem is that other people lack the insight about their original use and significance.

Out of these points, we can summarize the following points as to what experts demand from their visualizations: control of the focus of the visualization, good scalability so that they can be used on large practical problems, enough speed to be sufficiently responsive, and finally that they maintain their accuracy given the expert's simplifications.

\subsection{Multiple Representations}

Systems that visualize software usually display two or more views of the same information. Contrary to that it is better most of the time to utilize only one representation as that reduces mental strain from continuously switching between them, uses less screen space, avoids having to map the two onto each other, and eliminates the problem of synchronizing between the two.

However, sometimes multiple representations are required when one isn't sufficient. If that is the case, the users must learn to work between them, how they fit together, and keep track of them in parallel. This is called inter-representational reasoning. The reasons for using more than one representation are varied.

The simplest case is when the user utilizes representations separately from each other. This means that when the programmer switches to another representation, he also switches tasks. The reason for this is that often different tasks warrant different visualizations.

Multiple identical representations are used when the user requires different views on a conceptual space. A basic example of this is when a 3d object is represented in multiple 2d views.

Another reason is when a representation requires another representation to allow the user to reason on the first. These bridging representations help the user understand problem-oriented visualizations that are in themselves not easily understood. In a way, the second layer is a kind of meta representation.

A more interesting reason is when the differences in representations are required to encompass the whole problem. This is called heterogeneous inference. The idea here is that by forcing the user to work with two (possibly complimentary) representations, he is forced to a higher level of abstraction which in turn could offer advantageous for solving the whole problem.

The final reason given in the original paper is that multiple representations force the user to think beyond just a single visualization, thus possibly bringing the user to understand the first visualization beyond his initial impression by forcing him to solve the differences between the two. This is called useful awkwardness.

\subsection{Influence of Conventions on Visualizations}

How well a visualization can achieve its goal of making information visible also depends on the reader. Creating a visualization one must be aware what kind of readers the targeted audience are. One must concider the cultural background, because conventions may vary among sub-cultures. The skill level of the readership is also very important, because novice readers get easily distracted by surface features and may confuse visibility with relevance.


conflict between mathematical and metaphorical conventions

SV strongly depends on: (for widespread use)

conflicting metaphors

commercial interests

unsupported intuitions

\section{Conclusion}

don’t assume too much

can’t highlight everything

do not presume upon your user’s contexts

SV can at present only be designed for one context

spontaneousness of programmers at solving problems ignored at own risk

%%  Der Text der Ausarbeitung ist hier zu Ende.
%%  Die nächste Zeile bleibt unverändert.
\bibliographystyle{plain}
\bibliography{seminar}

\end{document}
