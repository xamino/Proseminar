\documentclass[11pt, a4paper, ngerman, twoside]{article}

%% Die folgende Anleitung gilt für Linux:
%%
%%  Die Übersetzung dieses Dokuments erfolgt mit (ggf. öfter aufrufen):
%%  pdflatex seminar.tex
%%
%%  Falls die Bibliographie geändert wurde, dann zusätzlich:
%%  bibtex seminar
%%
%%  Bitte darauf achten, dass pdflatex und bibtex keine Warnungen und
%%  keine Fehler melden.
%%
%%  Das Ergebnis kann man ansehen:
%%  acroread seminar.pdf
%%
%%  Die Quelldatei einer deutschen Rechtschreibprüfung unterziehen:
%%  ispell -d deutsch -T latin1 seminar.tex

%%  Zur Unterstuetzung von Umlauten:
%\usepackage{ngerman}
%%  Die Kodierung des Dokuments wird angegeben durch:
\usepackage[utf8]{inputenc}

\usepackage{amssymb,amsthm,graphicx}
\usepackage{hyperref} % important: load after float
\hypersetup{
	pdfproducer={pdfeTex 3.14159-1.30.6-2.2},
	colorlinks=false,
	pdfborder=0 0 0	% keine Box um die Links!
}

\oddsidemargin0mm
\evensidemargin0mm
\textwidth159.2mm
\topmargin0mm
\headheight0mm
\textheight43\baselineskip
\usepackage{url}
\urlstyle{rm}

%%  Die Seitennumerierung wird später von uns korrigiert.
\setcounter{page}{1}

%% Die Konfiguration eigener Header und Footer
%% ermöglicht beispielsweise das Paket
\usepackage{fancyhdr}
%% Die folgenden Zeilen konfigurieren das Paket für unsere Zwecke
\fancypagestyle{plain}{\fancyhf{}\fancyfoot[RO,LE]{\thepage}\renewcommand\headrulewidth{0pt}}
\fancyhf{}
\fancyhead[LE]{\myauthor}
\fancyhead[RO]{\mytitle}
\fancyfoot[RO,LE]{\thepage}
%% Hier setzen wir den Stil der Seiten des Dokuments so,
%% dass das von uns konfigurierte Paket fancyhr verwendet wird.
\pagestyle{fancy}

%%  Die Theorem-Umgebungen sind in amsthdoc.pdf beschrieben:
\renewcommand{\proofname}{Beweis}
\theoremstyle{plain}\newtheorem{Lemma}{Lemma}
\theoremstyle{plain}\newtheorem{Satz}[Lemma]{Satz}
\theoremstyle{definition}\newtheorem{Definition}[Lemma]{Definition}
\theoremstyle{definition}\newtheorem*{Beispiel}{Beispiel}
\theoremstyle{remark}\newtheorem*{Bemerkung}{Bemerkung}

%% Das Argument zu Date soll leer bleiben, 
%% damit dem Titel kein Datum hinzugefügt wird.
\date{}

% % % Ab hier sollte das Dokument bearbeitet werden! % % % 
%% Eigene \usepackage und \newcommand Befehle sind hier einzufügen.
%% Vor der Verwendung anderer Pakete muss eine Rücksprache mit dem Betreuer erfolgen.
% % %

\newcommand{\isdef}{=_{\mathrm{def}}}
\newcommand{\N}{\mathbb{N}}

\begin{document}
%%  Die Überschrift der Ausarbeitung ist zwischen {}
%%  in der nächsten Zeile einzutragen.
\title{Cognitive Questions in Software Visualization}
%%  Der Name des Autors oder die Namen der Autoren sind 
%%zwischen {} in der nächsten Zeile einzutragen.
\author{Frank Richter, Tamino Hartmann}

%%  Die nächste fünf Zeilen müssen unverändert bleiben!
\makeatletter
\let\mytitle\@title
\let\myauthor\@author
\makeatother
\maketitle
%% ab hier darf das Dokument wieder verändert werden!
\begin{abstract}



\end{abstract}

%%  Der Text der Ausarbeitung ist hier einzufügen.
%%  Er sollte 8-10 Seiten umfassen.
%%  Die Gliederung erfolgt mit \section und \subsection Befehlen.
%%  Referenzen innerhalb des Texts erfolgen mit \label und \ref Befehlen.
%%  Referenzen auf Literatur erfolgen mit dem \cite Befehl.
\section{Introduction}
The goal of software visualization is to help the reader understand a complex matter. It is trying to make up for inexpertness in readership by expertise in presentation. The major difficulty with software visualization lies in the fact, that it is presenting information artefacts and not physical objects. Another problem poses the question what kind of visualization is actually suitable for which situation.
There are different types of visualizations to represent the code, the data or the algorithm\cite{myers}. Additionally there should be made a distinction between external structure versus representation of cognitive structure and representations of structure versus representations of purpose or expectation\cite{origin}.

Each type of visualization has different aims and uses. A visualization that is presenting large data sets is making the attempt to provide a data picture that makes the data available for interpretation, while a visualization in form of a virtual machine is mostly used to show how a program behaves. Other visualizations try to change the perspective, to attempt to control complexity by visualizing the overall structure. Another type of visualizations are those that attempt a display-based reasoning by shifting the focus of the representation to allow the user different tactics in finding, recalling, examining, or comparing information\cite{davies1993}\cite{davies1996}.

Currently we are lacking software visualisations that are concentrating on a cognitive representation and, aside from the domain of code, don't even really know to represent something in a cognitive way.


\section{Reasons for using Software Visualizations}

One of the questions that need to be answered for this paper is the reasons for using visualizations when developing software. The original paper does this by dividing visualizations into two distinctions: one concerning when software experts use them and one when non-experts use visualizations. It is important to note though that the two are not exclusive, meaning that a visualization can be utilized by both groups too.

Experts use software visualizations for example to externalize images of thought, to set aside information, to create a focus for transferring knowledge transfer, to provide tools for thinking, and to fully utilize the computer as a collaborator when solving problems.\footnote{TODO: Does the following really need to be here? Can we kill it without loosing pages?} Externalizing images of thought are done by visualizations that are closely modeled after the mental image the expert has. Using visualizations to set aside information is used to keep a problem solvable in manageable chunks by freeing already thought about parts from parts that still need work. When the visualization is focused on knowledge transfer, the intention is often to make a discussion easier by offering a common ground from which to work. Visualizations that are used as an aid to a process of thought are used as tools. These supplementary representations are used to offload information, to provide alternative views of a problem, to provide a visual mapping of the problem, and to provide a possibility for the expert to keep track of the relationships between sub-problems. Visualizations that are created to use the computer as an active collaborator are used to keep track of what the computer does towards solving the larger problem, such as when a solution is not apparent and the path to it must be taken step by step.

Non-experts use visualizations mostly as a tool to get a glimpse of an expert's mental imagery, an expert's reasoning process, to provide tools for them that are consistent with how an expert behaves, to provide a model of execution, and to show additional information or aspects that are hard to envision for novices.

Comparing the two, the original paper states the assumption that novices have a less developed or inappropriate mental imagery as compared to experts. Generally, one could fathom that visualizations are used as tools by experts for specific problems and as aids by novices to understand how an expert would tackle a task. Worded differently, visualizations for novices often have an instructive role as compared to when they are utilized by experts. It becomes apparent that to understand a visualization, an insight into their use is required.

\section{Graphical Visualizations and their Aspects}

It is difficult to clearly distinguish visualizations from other ways of viewing software. An important point when considering this is that in print media, there is no longer a clear separation between graphics and typography. Therefore the original paper comes to the conclusion that visualizations are in essence an alternative representation or alternative emphasis within a representation. However, it is interesting to note that there is evidence that graphical representations are proving harder to work with when compared to purely textual ones. So when should they still be used? Mainly when a richer representation is required, when accessibility and comprehensibility are important, and when the interaction should be more fun for the people who will utilize it\footnote{This is because creative working is encouraged stronger when a representation is more graphical.}. Especially accessibility can be an important point to consider, as the illusion of accessibility can be more important than general effectiveness to encourage actual use of the representation.\footnote{TODO: I kept it REALLY short here, can be expanded!}

\section{Concepts of Visualizations}

\subsection{Tasks of Visualizations}

The task of a visualization is to support the user towards what he intends to do. However, visualization systems rarely come with a description for which tasks they are intended to support specifically. It has been shown that programmers that cross-reference between the program world and the domain world receive the higher comprehension scores\cite{penn}. The original paper therefore concludes that to be helpful, a visualization not only needs to illustrate the code but also the algorithm in a useful form.

There are two axioms about information representation: finding and using information is easier when the form of the information sought has a cognitive fit; and presentation highlights some kind of information but likely obscures other kinds at the same time. These might explain why some animation systems using code steppers have not proven to be generally successful methods in helping code comprehension, as they force the user to view the code in order of execution compared to goal-oriented, the most sought after information users try to extract.

To utilize the axioms effectively, it is necessary to understand what programmers actually do, how to support them in their tasks, and how visualization systems change these tasks.

\subsection{Information Dimensions in Visualizations}

Different visualizations are using different dimensions for the representation of information. Text is linear and apparently has one dimension, while a picture is two dimensional. An animated visualization is basicly moving pictures what is adding another dimension to the two dimensions pictures initially have. By using a virtual reality system that the human brain interprates as something three dimensional it is possible to add another dimension.

Taking a closer look at text one will notice, that text actually is not one dimensional. Code was not written in a linear way and no one but a compiler reads it in a linear way. Human readers of source code take not of secondary notation \cite{green} like indentation, patterns, text formation and comments with ASCII signs.

In printed graphic image there are eight variables\cite{bertin}. There are the X and Y dimensions and marks with the density of ink, sizie, texture, color, orientation and shape as variables. This is e.g. used in editors with syntax highlighting.

Due to the limited view of a human, using more than two dimensions comes at a cost. One will basicly allways be limited to a two dimensional picture of one specific point of time. This leads to the conclusion, that it might be best if one first tried to represent as much information as possible by using only two dimensions.

\subsection{Influence of Personal Skill and Variation}

readership skills

visibility doesn’t guarantee effective interpretation

novice readers lack search an inspection strategies and get distracted by surface features

experts are better at recognising what is relevant and disregarding the irrelevant

visibility is in the eye of the beholder

graphical cultures: little of graphical culture is codified and some conventions vary among sub-cultures

presentation skills: guiding the reader by associating perceptual cues

cognitive style

experts have a tendency to create a visualization for a particular problem even if it will never be useful for another problem

software visualization is for coping with unknowns

other person’s visualization used seldom because the SV are made for single problem, and thus not applicable to current software

experts want from SV (comparable to programming languages) control, scale, speed, truth

\subsection{Multiple Representations}

SV usually presents two or more informations

usually one better

use of multiple representations:

used separately

different views on a conceptual space

bridging representations (one to understand the other)

heterogeneous inference (alternation between the two required to comprehend problem)

useful awkwardness (???)

\subsection{Influence of Conventions on Visualizations}

interpretation of visualization is influenced by general knowledge of graphical conventions

conflict between mathematical and metaphorical conventions

SV strongly depends on: (for widespread use)

cultural dependency

conflicting metaphors

commercial interests

unsupported intuitions

\section{Conclusion}

don’t assume too much

can’t highlight everything

do not presume upon your user’s contexts

SV can at present only be designed for one context

spontaneousness of programmers at solving problems ignored at own risk

%%  Der Text der Ausarbeitung ist hier zu Ende.
%%  Die nächste Zeile bleibt unverändert.
\bibliographystyle{plain}
\bibliography{seminar}

\end{document}
